{% extends 'base.html' %}

{% block content %}
<style>
    .chat-container { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: #fff; }
    .chat-header { padding: 15px; border-bottom: 1px solid #eee; display: flex; align-items: center; justify-content: space-between; background: #fff; }
    .messages-area { flex: 1; padding: 20px; overflow-y: auto; background-image: radial-gradient(#e5e7eb 1px, transparent 1px); background-size: 20px 20px; }
    
    .message-bubble { max-width: 75%; padding: 10px 15px; border-radius: 15px; margin-bottom: 10px; position: relative; font-size: 0.95rem; }
    .msg-received { background: #f0f2f5; align-self: flex-start; border-bottom-left-radius: 2px; }
    .msg-sent { background: #6c5ce7; color: white; align-self: flex-end; margin-left: auto; border-bottom-right-radius: 2px; }
    
    .chat-input-area { padding: 15px; background: white; border-top: 1px solid #eee; }
    .sender-name { font-size: 0.75rem; margin-bottom: 4px; font-weight: 600; color: #555; }
    /* Add this to your existing <style> block */
#micBtn {
    background: #ff9f43; /* Orange */
    border: none;
    color: white;
    width: 45px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    transition: all 0.3s ease;
}
#micBtn:hover { background: #e67e22; }
#micBtn.listening {
    background: #ef4444; /* Red */
    animation: pulse 1.5s infinite;
}
@keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
</style>

<div class="chat-container">
    <div class="chat-header shadow-sm">
        <a href="{% url 'users:profile' other_user.username %}" class="d-flex align-items-center gap-3 text-decoration-none text-dark">
            <img src="{{ other_user.profile.get_avatar_url }}" class="avatar-circle">
            <div>
                <h5 class="m-0 fw-bold">{{ other_user.username }}</h5>
                <small class="text-muted">Direct Message</small>
            </div>
        </a>
    </div>

    <div class="messages-area d-flex flex-column" id="chat-box">
        {% for m in chat_messages %}
            <div class="message-bubble {% if m.sender == request.user %}msg-sent{% else %}msg-received{% endif %}">
                {{ m.content|linebreaksbr }}
                <div class="text-end opacity-75" style="font-size: 0.7rem; margin-top: 4px;">
                    {{ m.timestamp|date:"H:i" }}
                </div>
            </div>
        {% empty %}
            <div class="text-center text-muted mt-5">
                <i class="bi bi-chat-text fs-1"></i>
                <p>Say hello to {{ other_user.username }}!</p>
            </div>
        {% endfor %}
    </div>

    <div class="chat-input-area">
    <div class="input-group">
        <button class="btn" type="button" id="micBtn" onclick="toggleSpeech()">
            <i class="bi bi-mic-fill"></i>
        </button>
        
        <input type="text" id="msgInput" class="form-control border-0 bg-light" placeholder="Type or speak..." style="padding: 12px;">
        
        <button id="sendBtn" class="btn btn-primary px-4"><i class="bi bi-send-fill"></i></button>
    </div>
</div>
</div>
<script>
    const other = "{{ other_user.username }}";
    const currentUser = "{{ request.user.username }}";
    const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
    const url = `${wsScheme}://${window.location.host}/ws/direct/${other}/`;
    const sock = new WebSocket(url);
    const chatBox = document.getElementById("chat-box");

    // Scroll to bottom on load
    chatBox.scrollTop = chatBox.scrollHeight;

    sock.onmessage = (ev) => {
        const d = JSON.parse(ev.data); // Variable is 'd' here
        const isMe = d.sender === currentUser;
        
        const div = document.createElement("div");
        div.className = `message-bubble ${isMe ? 'msg-sent' : 'msg-received'}`;
        
        // --- TIME FIX START ---
        // Use 'd.timestamp', fallback to current time if missing
        const date = new Date(d.timestamp || Date.now());
        const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        // --- TIME FIX END ---

        let html = "";
        html += `${d.message.replace(/\n/g, '<br>')}`;
        html += `<div class="text-end opacity-75" style="font-size: 0.7rem; margin-top: 4px;">${timeStr}</div>`;

        div.innerHTML = html;
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
    };

    const input = document.getElementById("msgInput");
    const btn = document.getElementById("sendBtn");

    if(btn){
        btn.onclick = sendMessage;
        input.onkeyup = function(e) {
            if (e.keyCode === 13) sendMessage();
        };
    }

    function sendMessage() {
        const v = input.value.trim();
        if (v) {
            sock.send(JSON.stringify({message: v}));
            input.value = "";
        }
    }
    // --- VOICE LOGIC START ---
const micBtn = document.getElementById("micBtn");
const msgInput = document.getElementById("msgInput"); // Note: Group chat uses 'msgInput', not 'aiInput'

let recognition = null;
let listening = false;

if ('webkitSpeechRecognition' in window) {
    recognition = new webkitSpeechRecognition();
    recognition.lang = 'en-IN'; // Default to Indian English (Good for Hinglish)
    recognition.interimResults = false;
    recognition.continuous = false;

    recognition.onstart = () => {
        listening = true;
        micBtn.classList.add("listening");
        micBtn.innerHTML = '<i class="bi bi-stop-fill"></i>'; 
    };

    recognition.onresult = (event) => {
        const spoken = event.results[0][0].transcript;
        msgInput.value = spoken; // Puts text into input
        // Optional: Auto-send
        // sendMessage(); 
    };

    recognition.onend = () => {
        stopSpeech();
    };

    recognition.onerror = (event) => {
        console.error("Speech Error:", event.error);
        if(event.error !== 'no-speech') {
            // alert("Voice Error: " + event.error); // Optional: Enable if you want alerts
        }
        stopSpeech();
    };
} else {
    if(micBtn) micBtn.style.display = 'none'; // Hide if not supported
}

function toggleSpeech() {
    if (!recognition) return;
    if (!listening) {
        recognition.start();
    } else {
        recognition.stop();
    }
}

function stopSpeech() {
    listening = false;
    if(micBtn) {
        micBtn.classList.remove("listening");
        micBtn.innerHTML = '<i class="bi bi-mic-fill"></i>';
    }
}
// --- VOICE LOGIC END ---
</script>
{% endblock %}